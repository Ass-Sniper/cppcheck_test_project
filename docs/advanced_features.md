# 高级分析特性支持

本项目集成的 `check_advanced.sh` 脚本实现了对现代 Cppcheck 链的完美适配。

### 核心能力：
1. **增量扫描**：通过 `.cppcheck_cache` 目录缓存分析状态。如果代码没有变动，二次执行 `make check-adv` 的速度将提升 5-10 倍。
2. **穷举模式**：自动开启 `--check-level=exhaustive`，利用更强的算力换取 0 漏报。
3. **标准库感知**：自动加载 `std.cfg`，识别所有 C++ 标准库函数的边界限制。
4. **HTML 自动集成**：无需手动干预，从扫描到可视化一气呵成。


## 性能优化：增量分析 (Incremental Analysis)

为了优化开发体验，本项目默认开启了增量分析特性。

- **配置方式**: 通过 `--cppcheck-build-dir` 指定缓存路径。
- **本地路径**: 项目根目录下的 `.cppcheck_cache/`。
- **使用建议**:
    - 在 CI 环境中，可以通过缓存该目录（如 GitHub Actions 的 `actions/cache`）来加速流水线。
    - 在本地开发时，增量分析允许你在几秒钟内获得关于当前修改的反馈。



## 附1：cppcheck增量分析 (Incremental Analysis) 特性详解

在 Cppcheck 中，增量分析是一项通过**缓存机制**大幅提升后续扫描效率的技术。它的核心思想是：**“只分析变动的部分，不重复扫描未改动的代码。”**

对于中大型项目，完整扫描可能耗时数分钟甚至数小时，而开启增量扫描后，二次运行通常只需数秒。

---

### 1. 工作原理

当你指定了 `--cppcheck-build-dir=<dir>` 参数时，Cppcheck 会在指定的目录下为每个源文件生成分析快照（通常是 `.dump` 文件和哈希记录）。

* **首次扫描**：Cppcheck 对所有代码进行全量分析，并将结果、宏定义状态、头文件依赖关系及文件的哈希值存入缓存目录。
* **后续扫描**：
1. 脚本启动后，Cppcheck 扫描项目文件并计算当前哈希。
2. 对比缓存目录中的记录。
3. **哈希未变**：直接从缓存中调取之前的分析结论。
4. **哈希改变/依赖项变动**：仅针对受影响的文件重新执行深度分析引擎。



---

### 2. 为什么在最新版本中至关重要？

在 Cppcheck 2.13+ 引入了 `--check-level=exhaustive`（穷举模式）后，分析的计算量呈指数级增长。

* **全量穷举扫描**：可能需要消耗 100% 的 CPU 并运行很长时间。
* **增量 + 穷举**：这种组合是最佳实践。它既保证了代码在提交前的检查深度，又避免了开发者在每次微调代码后都要经历漫长的等待。

---

### 3. 如何在脚本中正确开启

在你的 `check_advanced.sh` 中，我们通过以下逻辑实现了该特性：

```bash
# 定义缓存目录
BUILD_DIR="$rootdir/.cppcheck_cache"
mkdir -p "$BUILD_DIR"

# 关键参数：--cppcheck-build-dir
cppcheck --enable=all \
         --cppcheck-build-dir="$BUILD_DIR" \
         --project=compile_commands.json \
         ./src

```

> **注意**：建议配合 `compile_commands.json`（编译数据库）使用。因为如果编译选项（如 `-DDEBUG` 切换为 `-DRELEASE`）发生了变化，增量分析能识别出这些配置变动并自动触发重新扫描，防止漏报。

---

### 4. 增量分析的优势与限制

| 特性 | 说明 |
| --- | --- |
| **显著提速** | 对于仅修改个别文件的操作，提速可达 90% 以上。 |
| **全程序分析 (WPA)** | 即使开启增量模式，Cppcheck 依然能保留跨文件分析的能力。 |
| **磁盘占用** | 缓存目录会占用一定空间（取决于源文件数量），建议将其加入 `.gitignore`。 |
| **清理机制** | 若项目结构发生巨大变化，建议手动执行 `rm -rf .cppcheck_cache` 强制重置。 |

---
